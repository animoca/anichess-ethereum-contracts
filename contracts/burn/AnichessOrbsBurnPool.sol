// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {ERC1155TokenReceiver} from "@animoca/ethereum-contracts/contracts/token/ERC1155/ERC1155TokenReceiver.sol";
import {IERC1155Burnable} from "@animoca/ethereum-contracts/contracts/token/ERC1155/interfaces/IERC1155Burnable.sol";
import {ForwarderRegistryContext} from "@animoca/ethereum-contracts/contracts/metatx/ForwarderRegistryContext.sol";
import {ForwarderRegistryContextBase} from "@animoca/ethereum-contracts/contracts/metatx/base/ForwarderRegistryContextBase.sol";
import {IForwarderRegistry} from "@animoca/ethereum-contracts/contracts/metatx/interfaces/IForwarderRegistry.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";
import "hardhat/console.sol";

/**
 * @title AnichessOrbsBurnPool Contract
 * @dev This contract allows users to burn tokens and calculate rewards based on the amount of tokens burned.
 */
contract AnichessOrbsBurnPool is ForwarderRegistryContext, ERC1155TokenReceiver {
    using MerkleProof for bytes32[];

    /// @notice The denominator for the multiplier.
    uint256 immutable DENOMINATOR = 10_000;

    /// @notice The token ID of RoC for setting the token multiplier.
    uint256 immutable MISSING_ORB_TOKEN_ID = 1;

    /// @notice The IERC1155Burnable erc1155 contracts burn to generate ASH.
    IERC1155Burnable public immutable ORB_OF_POWER;

    /// @notice The initial time of the contract.
    uint256 public immutable INITIAL_TIME;

    /// @notice The duration of each cycle.
    uint256 public immutable CYCLE_DURATION;

    /// @notice The maximum cycle.
    uint256 public immutable MAX_CYCLE;

    /// @notice The IERC1155 erc1155 contract for setting the token multiplier.
    IERC1155Burnable public immutable MISSING_ORB;

    /// @notice The Merkle root for setting the anichess game multiplier.
    bytes32 public immutable MERKLE_ROOT;

    /// @notice The token multiplier.
    uint256 public immutable TOKEN_MULTIPLIER;

    /// @notice The total amount of ASH generated in each cycle.
    mapping(uint256 => uint256) public totalAshByCycle;

    /// @notice The total amount of ASH generated by each user in each cycle.
    mapping(uint256 => mapping(address => uint256)) public userAshByCycle;

    /// @notice The merkle leaf consumption status for the anichess game multiplier.
    mapping(bytes32 => bool) public leafConsumptionStatus;

    /// @notice The multiplier info for each user, first 128 bits are the anichess game multiplier numerator, last 128 bits are the token multiplier.
    mapping(address => uint256) public multiplierInfos;

    /// @notice The token weights for calculating Ash.
    mapping(uint256 => uint256) public tokenWeights;

    /// @notice Event emitted when ASH are generated.
    event GenerateAsh(
        address indexed burner,
        uint256 indexed cycle,
        uint256 timestamp,
        uint256[] ids,
        uint256[] values,
        uint256 totalAsh,
        uint256 multiplierInfo
    );

    /// @notice Event emitted when the multiplier info is updated.
    event UpdateMultiplierInfo(address indexed recipient, uint256 curr, uint256 updated);

    /// @notice Error thrown when the token ID is invalid.
    error InvalidTokenId(address token, uint256 tokenId);

    /// @notice Error thrown when the array lengths are inconsistent.
    error InconsistentArrays();

    /// @notice Error thrown when the token is not approved.
    error InvalidToken(address token);

    /// @notice Error thrown when the cycle is invalid.
    error InvalidCycle(uint256 cycle);

    /// @notice Error thrown when the token amount is invalid.
    error InvalidTokenValue(uint256 value, uint256 expectedValue);

    /// @notice Error thrown when the payout has already been claimed.
    error AlreadySetAnichessGameMultiplierNumerator(address recipient);

    /// @notice Error thrown when the wallet already has the token multiplier been set.
    error AlreadySetTokenMultiplier(address wallet);

    /// @notice Error thrown when the proof is invalid.
    error InvalidProof();

    /// @notice Error thrown when the token weight is already set.
    error AlreadySetTokenWeight(uint256 tokenId);

    /// @notice Error thrown when the cycle duration is invalid.
    error ZeroCycleDuration();

    /// @notice Error thrown when the cycle is invalid.
    error ZeroMaxCycle();

    /// @notice Error thrown when the leaf is already consumed.
    error AlreadyConsumedLeaf(bytes32 leaf);

    /**
     * @notice Constructor for the AnichessOrbsBurnPool contract.
     * @param initialTime The initial time of the contract.
     * @param cycleDuration The duration of each cycle.
     * @param maxCycle The maximum cycle.
     * @param orbOfPower The IERC1155Burnable erc1155 contract burn to generate ASH.
     * @param tokenIds The token IDs.
     * @param weights The weights for each token.
     * @param merkleRoot The Merkle root of the AnichessGame multiplier claim.
     * @param missingOrb The IERC1155Burnable erc1155 missing orb contract for setting the token multiplier.
     * @param tokenMultiplier The token multiplier.
     * @param forwarderRegistry The forwarder registry contract.
     * @dev Throws if the cycle duration is zero.
     * @dev Throws if the max cycle is zero.
     */
    constructor(
        uint256 initialTime,
        uint256 cycleDuration,
        uint256 maxCycle,
        IERC1155Burnable orbOfPower,
        uint256[] memory tokenIds,
        uint256[] memory weights,
        bytes32 merkleRoot,
        IERC1155Burnable missingOrb,
        uint256 tokenMultiplier,
        IForwarderRegistry forwarderRegistry
    ) ForwarderRegistryContext(forwarderRegistry) {
        INITIAL_TIME = initialTime;
        if (cycleDuration == 0) {
            revert ZeroCycleDuration();
        }
        CYCLE_DURATION = cycleDuration;
        if (maxCycle == 0) {
            revert ZeroMaxCycle();
        }
        MAX_CYCLE = maxCycle;
        MERKLE_ROOT = merkleRoot;
        MISSING_ORB = missingOrb;
        ORB_OF_POWER = orbOfPower;
        TOKEN_MULTIPLIER = tokenMultiplier;

        _setTokenWeights(tokenIds, weights);
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgSender() internal view virtual override(ForwarderRegistryContextBase) returns (address) {
        return ForwarderRegistryContextBase._msgSender();
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgData() internal view virtual override(ForwarderRegistryContextBase) returns (bytes calldata) {
        return ForwarderRegistryContextBase._msgData();
    }

    /**
     * @notice Set the token weights.
     * @param tokenIds The token IDs.
     * @param weights The weights for each token.
     * @dev Throws if the lengths of token IDs and weights are inconsistent.
     * @dev Throws if the token weight is already set.
     */
    function _setTokenWeights(uint256[] memory tokenIds, uint256[] memory weights) internal {
        if (tokenIds.length != weights.length) {
            revert InconsistentArrays();
        }

        for (uint256 i = 0; i < tokenIds.length; i++) {
            if (tokenWeights[tokenIds[i]] > 0) {
                revert AlreadySetTokenWeight(tokenIds[i]);
            }
            tokenWeights[tokenIds[i]] = weights[i];
        }
    }

    /**
     * @notice Set the AnichessGame multiplier numerator.
     * @param proof The Merkle proof for setting the anichess game multiple numberator.
     * @param recipient The recipient of the multiplier.
     * @param currMultiplierInfo The current multiplier info.
     * @param anichessGameMultiplierNumerator The AnichessGame multiplier numerator.
     * @dev Throws if the anichess game multiplier numerator is already set.
     * @dev Throws if the proof is invalid.
     * @dev Throws if the leaf is already consumed.
     * @return updatedMultiplierInfo The updated multiplier info.
     */
    function _setAnichessGameMultiplierNumerator(
        bytes32[] memory proof,
        address recipient,
        uint256 currMultiplierInfo,
        uint256 anichessGameMultiplierNumerator
    ) internal returns (uint256 updatedMultiplierInfo) {
        if ((uint128(currMultiplierInfo >> 128) > 0)) {
            revert AlreadySetAnichessGameMultiplierNumerator(recipient);
        }
        bytes32 leaf = keccak256(abi.encodePacked(recipient, anichessGameMultiplierNumerator));
        if (!proof.verify(MERKLE_ROOT, leaf)) {
            revert InvalidProof();
        }

        if (leafConsumptionStatus[leaf]) {
            revert AlreadyConsumedLeaf(leaf);
        }

        // mask the AnichessGame multiplier numerator to keep only the last 128 bits of the existing multiplier
        updatedMultiplierInfo = (currMultiplierInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (uint256(anichessGameMultiplierNumerator) << 128);
        multiplierInfos[recipient] = updatedMultiplierInfo;
        leafConsumptionStatus[leaf] = true;

        emit UpdateMultiplierInfo(recipient, currMultiplierInfo, updatedMultiplierInfo);
    }

    /**
     * @notice Get the current cycle.
     * @return cycle The current cycle.
     */
    function currentCycle() public view returns (uint256) {
        return (block.timestamp - INITIAL_TIME) / CYCLE_DURATION;
    }

    /**
     * @notice Set the AnichessGame multiplier through a Merkle proof.
     * @param proof The Merkle proof for the claim.
     * @param recipient The recipient of the payout.
     * @param newAnichessGameMultiplierNumerator The AnichessGame multiplier numerator for the recipient.
     * @dev Throws if the anichess game multiplier numerator is already set.
     * @dev Throws if the leaf is already consumed.
     * @dev Throws if the proof is invalid.
     */
    function setAnichessGameMultiplierNumerator(bytes32[] calldata proof, address recipient, uint256 newAnichessGameMultiplierNumerator) external {
        _setAnichessGameMultiplierNumerator(proof, recipient, multiplierInfos[recipient], newAnichessGameMultiplierNumerator);
    }

    /**
     * @notice Set the token multiplier by burning the Riddle of Chaos.
     * @notice and set the AnichessGame multiplier through a Merkle proof in the data field.
     * @param from The wallet address.
     * @param id The token ID.
     * @param value The token value.
     * @param data The data for setting the token multiplier.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the token ID is invalid.
     * @dev Throws if the token amount is invalid.
     * @dev Throws if the token multiplier has already been set.
     * @dev If the data is not empty, the proof and the anichessGameMultiplierNumerator are decoded from the data to set the AnichessGame multiplier numerator.
     */
    function onERC1155Received(address, address from, uint256 id, uint256 value, bytes calldata data) external override returns (bytes4) {
        if (msg.sender != address(MISSING_ORB)) {
            revert InvalidToken(msg.sender);
        }
        if (id != MISSING_ORB_TOKEN_ID) {
            revert InvalidTokenId(msg.sender, id);
        }

        if (value != 1) {
            revert InvalidTokenValue(value, 1);
        }

        uint256 currMultiplierInfo = multiplierInfos[from];

        if (uint128(currMultiplierInfo) > 0) {
            revert AlreadySetTokenMultiplier(from);
        }

        // mask the token multiplier to keep only the first 128 bits of the multiplier
        uint256 updatedMultiplierInfo = (currMultiplierInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000) | TOKEN_MULTIPLIER;
        multiplierInfos[from] = updatedMultiplierInfo;

        emit UpdateMultiplierInfo(from, currMultiplierInfo, updatedMultiplierInfo);

        // set the token multiplier if data is not empty
        if (data.length > 0) {
            // decode proof & newAnichessGameMultiplierNumerator from data
            (bytes32[] memory proof, uint256 anichessGameMultiplierNumerator) = abi.decode(data, (bytes32[], uint256));
            _setAnichessGameMultiplierNumerator(proof, from, updatedMultiplierInfo, anichessGameMultiplierNumerator);
        }

        return this.onERC1155Received.selector;
    }

    /**
     * @notice Burn the tokens and calculate the ash.
     * @param from The wallet address.
     * @param ids The token IDs to burn.
     * @param values The amount of tokens to burn.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the cycle is invalid.
     * @dev Throws if the token ID is invalid.
     */
    function onERC1155BatchReceived(
        address,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata
    ) external override returns (bytes4) {
        if (msg.sender != address(ORB_OF_POWER)) {
            revert InvalidToken(msg.sender);
        }

        uint256 cycle = currentCycle();
        if (cycle > MAX_CYCLE) {
            revert InvalidCycle(cycle);
        }

        uint256 totalAsh = 0;
        // calculate total burned
        for (uint256 i = 0; i < ids.length; i++) {
            uint256 weight = tokenWeights[ids[i]];
            if (weight == 0) {
                revert InvalidTokenId(msg.sender, ids[i]);
            }
            totalAsh += (values[i] * weight);
        }
        // boost the total ash based on the multipliers
        uint256 multiplierInfo = multiplierInfos[from];
        uint256 tokenMultiplier = uint128(multiplierInfo);
        uint128 anichessGameMultiplierNumerator = uint128(multiplierInfo >> 128);

        if (tokenMultiplier > 0) {
            totalAsh *= tokenMultiplier;
        }
        if (anichessGameMultiplierNumerator > 0) {
            totalAsh = (totalAsh * anichessGameMultiplierNumerator) / DENOMINATOR;
        }

        // update the user status
        userAshByCycle[cycle][from] += totalAsh;
        // update the pool status
        totalAshByCycle[cycle] += totalAsh;

        IERC1155Burnable(msg.sender).batchBurnFrom(address(this), ids, values);
        emit GenerateAsh(from, cycle, block.timestamp, ids, values, totalAsh, multiplierInfo);

        return this.onERC1155BatchReceived.selector;
    }
}
