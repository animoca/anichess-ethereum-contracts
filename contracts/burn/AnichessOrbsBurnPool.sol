// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {ERC1155TokenReceiver} from "@animoca/ethereum-contracts/contracts/token/ERC1155/ERC1155TokenReceiver.sol";
import {IERC1155Burnable} from "@animoca/ethereum-contracts/contracts/token/ERC1155/interfaces/IERC1155Burnable.sol";
import {ForwarderRegistryContext} from "@animoca/ethereum-contracts/contracts/metatx/ForwarderRegistryContext.sol";
import {ForwarderRegistryContextBase} from "@animoca/ethereum-contracts/contracts/metatx/base/ForwarderRegistryContextBase.sol";
import {IForwarderRegistry} from "@animoca/ethereum-contracts/contracts/metatx/interfaces/IForwarderRegistry.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title AnichessOrbsBurnPool Contract
 * @dev This contract allows users to burn tokens and calculate rewards based on the amount of tokens burned.
 */
contract AnichessOrbsBurnPool is ForwarderRegistryContext, ERC1155TokenReceiver {
    using MerkleProof for bytes32[];

    /// @notice The denominator for the multiplier.
    uint256 constant DENOMINATOR = 10_000;

    /// @notice The token ID of RoC for setting the token multiplier.
    uint256 constant MISSING_ORB_TOKEN_ID = 1;

    /// @notice The token weights for calculating Ash.
    uint256 constant ORB_TOKEN_WEIGHT_1 = 1;
    uint256 constant ORB_TOKEN_WEIGHT_2 = 3;
    uint256 constant ORB_TOKEN_WEIGHT_3 = 3;
    uint256 constant ORB_TOKEN_WEIGHT_4 = 5;
    uint256 constant ORB_TOKEN_WEIGHT_5 = 9;
    uint256 constant ORB_TOKEN_WEIGHT_6 = 25;
    uint256 constant ORB_TOKEN_WEIGHT_7 = 16;

    /// @notice The token multiplier.
    uint256 public constant TOKEN_MULTIPLIER = 2;

    /// @notice The IERC1155Burnable erc1155 contracts burn to generate ASH.
    IERC1155Burnable public immutable ORB_OF_POWER;

    /// @notice The IERC1155 erc1155 contract for setting the token multiplier.
    IERC1155Burnable public immutable MISSING_ORB;

    /// @notice The initial time of the contract.
    uint256 public immutable INITIAL_TIME;

    /// @notice The duration of each cycle.
    uint256 public immutable CYCLE_DURATION;

    /// @notice The maximum cycle.
    uint256 public immutable MAX_CYCLE;

    /// @notice The Merkle root for setting the anichess game multiplier.
    bytes32 public immutable MERKLE_ROOT;

    /// @notice The total amount of ASH generated in each cycle.
    mapping(uint256 => uint256) public totalAshPerCycle;

    /// @notice The total amount of ASH generated by each user in each cycle.
    mapping(uint256 => mapping(address => uint256)) public userAshPerCycle;

    /// @notice The merkle leaf consumption status for the anichess game multiplier.
    mapping(bytes32 => bool) public leafConsumptionStatus;

    /// @notice The multiplier info for each user, first 128 bits are the anichess game multiplier numerator, last 128 bits are the token multiplier.
    mapping(address => uint256) public multiplierInfos;

    /// @notice Event emitted when ASH are generated.
    event GenerateAsh(address indexed burner, uint256 indexed cycle, uint256[] ids, uint256[] values, uint256 ash, uint256 multiplierInfo);

    /// @notice Event emitted when the multiplier info is updated.
    event UpdateMultiplierInfo(address indexed recipient, uint256 curr, uint256 updated);

    /// @notice Error thrown when the token ID is invalid.
    error InvalidTokenId(address token, uint256 tokenId);

    /// @notice Error thrown when the token is not approved.
    error InvalidToken(address token);

    /// @notice Error thrown when the cycle is invalid.
    error InvalidCycle(uint256 cycle);

    /// @notice Error thrown when the token amount is invalid.
    error InvalidTokenValue(uint256 value, uint256 expectedValue);

    /// @notice Error thrown when the payout has already been claimed.
    error AlreadySetAnichessGameMultiplierNumerator(address recipient);

    /// @notice Error thrown when the wallet already has the token multiplier been set.
    error AlreadySetTokenMultiplier(address wallet);

    /// @notice Error thrown when the proof is invalid.
    error InvalidProof();

    /// @notice Error thrown when the cycle duration is invalid.
    error ZeroCycleDuration();

    /// @notice Error thrown when the cycle is invalid.
    error ZeroMaxCycle();

    /// @notice Error thrown when the leaf is already consumed.
    error AlreadyConsumedLeaf(bytes32 leaf);

    /**
     * @notice Constructor for the AnichessOrbsBurnPool contract.
     * @param initialTime The initial time of the contract.
     * @param cycleDuration The duration of each cycle.
     * @param maxCycle The maximum cycle.
     * @param orbOfPower The IERC1155Burnable erc1155 contract burn to generate ASH.
     * @param merkleRoot The Merkle root of the AnichessGame multiplier claim.
     * @param missingOrb The IERC1155Burnable erc1155 missing orb contract for setting the token multiplier.
     * @param forwarderRegistry The forwarder registry contract.
     * @dev Throws if the cycle duration is zero.
     * @dev Throws if the max cycle is zero.
     */
    constructor(
        uint256 initialTime,
        uint256 cycleDuration,
        uint256 maxCycle,
        IERC1155Burnable orbOfPower,
        bytes32 merkleRoot,
        IERC1155Burnable missingOrb,
        IForwarderRegistry forwarderRegistry
    ) ForwarderRegistryContext(forwarderRegistry) {
        INITIAL_TIME = initialTime;
        if (cycleDuration == 0) {
            revert ZeroCycleDuration();
        }
        CYCLE_DURATION = cycleDuration;
        if (maxCycle == 0) {
            revert ZeroMaxCycle();
        }
        MAX_CYCLE = maxCycle;
        MERKLE_ROOT = merkleRoot;
        MISSING_ORB = missingOrb;
        ORB_OF_POWER = orbOfPower;
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgSender() internal view virtual override(ForwarderRegistryContextBase) returns (address) {
        return ForwarderRegistryContextBase._msgSender();
    }

    /// @inheritdoc ForwarderRegistryContextBase
    function _msgData() internal view virtual override(ForwarderRegistryContextBase) returns (bytes calldata) {
        return ForwarderRegistryContextBase._msgData();
    }

    /**
     * @notice Set the AnichessGame multiplier numerator.
     * @param proof The Merkle proof for setting the anichess game multiple numberator.
     * @param recipient The recipient of the multiplier.
     * @param currMultiplierInfo The current multiplier info.
     * @param anichessGameMultiplierNumerator The AnichessGame multiplier numerator.
     * @dev Throws if the anichess game multiplier numerator is already set.
     * @dev Throws if the proof is invalid.
     * @dev Throws if the leaf is already consumed.
     * @return updatedMultiplierInfo The updated multiplier info.
     */
    function _setAnichessGameMultiplierNumerator(
        bytes32[] memory proof,
        address recipient,
        uint256 currMultiplierInfo,
        uint256 anichessGameMultiplierNumerator
    ) internal returns (uint256 updatedMultiplierInfo) {
        if ((uint128(currMultiplierInfo >> 128) > 0)) {
            revert AlreadySetAnichessGameMultiplierNumerator(recipient);
        }
        bytes32 leaf = keccak256(abi.encodePacked(recipient, anichessGameMultiplierNumerator));
        if (!proof.verify(MERKLE_ROOT, leaf)) {
            revert InvalidProof();
        }

        if (leafConsumptionStatus[leaf]) {
            revert AlreadyConsumedLeaf(leaf);
        }

        // mask the AnichessGame multiplier numerator to keep only the last 128 bits of the existing multiplier
        updatedMultiplierInfo = (currMultiplierInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) | (uint256(anichessGameMultiplierNumerator) << 128);
        multiplierInfos[recipient] = updatedMultiplierInfo;
        leafConsumptionStatus[leaf] = true;

        emit UpdateMultiplierInfo(recipient, currMultiplierInfo, updatedMultiplierInfo);
    }

    /**
     * @notice Get the current cycle.
     * @return cycle The current cycle.
     */
    function currentCycle() public view returns (uint256) {
        return (block.timestamp - INITIAL_TIME) / CYCLE_DURATION;
    }

    /**
     * @notice Set the token multiplier by burning the Riddle of Chaos.
     * @notice and set the AnichessGame multiplier through a Merkle proof in the data field.
     * @param from The wallet address.
     * @param id The token ID.
     * @param value The token value.
     * @param data The merkle proof data and multiplier value for setting the token multiplier.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the cycle is invalid.
     * @dev Throws if the token ID is invalid.
     * @dev Throws if the token amount is invalid.
     * @dev Throws if the token multiplier has already been set.
     */
    function onERC1155Received(address, address from, uint256 id, uint256 value, bytes calldata data) external override returns (bytes4) {
        if (msg.sender != address(MISSING_ORB)) {
            revert InvalidToken(msg.sender);
        }
        if (id != MISSING_ORB_TOKEN_ID) {
            revert InvalidTokenId(msg.sender, id);
        }

        if (value != 1) {
            revert InvalidTokenValue(value, 1);
        }

        uint256 cycle = currentCycle();
        if (cycle > MAX_CYCLE) {
            revert InvalidCycle(cycle);
        }

        uint256 currMultiplierInfo = multiplierInfos[from];

        if (uint128(currMultiplierInfo) > 0) {
            revert AlreadySetTokenMultiplier(from);
        }

        // mask the token multiplier to keep only the first 128 bits of the multiplier
        uint256 updatedMultiplierInfo = (currMultiplierInfo & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000000000000000000000000000) | TOKEN_MULTIPLIER;
        multiplierInfos[from] = updatedMultiplierInfo;

        // set the token multiplier if data is not empty
        if (data.length > 0) {
            // decode proof & newAnichessGameMultiplierNumerator from data
            (bytes32[] memory proof, uint256 anichessGameMultiplierNumerator) = abi.decode(data, (bytes32[], uint256));
            _setAnichessGameMultiplierNumerator(proof, from, updatedMultiplierInfo, anichessGameMultiplierNumerator);
        }

        IERC1155Burnable(msg.sender).burnFrom(address(this), id, value);
        emit UpdateMultiplierInfo(from, currMultiplierInfo, updatedMultiplierInfo);

        return this.onERC1155Received.selector;
    }

    /**
     * @notice Burn the tokens and calculate the ash.
     * @param from The wallet address.
     * @param ids The token IDs to burn.
     * @param values The amount of tokens to burn.
     * @param data The merkle proof data and multiplier value for setting the token multiplier.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the cycle is invalid.
     * @dev Throws if the token ID is invalid.
     * @dev Throws if the token amount is invalid.
     */
    function onERC1155BatchReceived(
        address,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external override returns (bytes4) {
        if (msg.sender != address(ORB_OF_POWER)) {
            revert InvalidToken(msg.sender);
        }

        uint256 cycle = currentCycle();
        if (cycle > MAX_CYCLE) {
            revert InvalidCycle(cycle);
        }

        uint256 totalAsh = 0;
        // calculate total burned
        for (uint256 i = 0; i < ids.length; i++) {
            uint256 weight = 0;
            if (ids[i] == 1) {
                weight = ORB_TOKEN_WEIGHT_1;
            } else if (ids[i] == 2) {
                weight = ORB_TOKEN_WEIGHT_2;
            } else if (ids[i] == 3) {
                weight = ORB_TOKEN_WEIGHT_3;
            } else if (ids[i] == 4) {
                weight = ORB_TOKEN_WEIGHT_4;
            } else if (ids[i] == 5) {
                weight = ORB_TOKEN_WEIGHT_5;
            } else if (ids[i] == 6) {
                weight = ORB_TOKEN_WEIGHT_6;
            } else if (ids[i] == 7) {
                weight = ORB_TOKEN_WEIGHT_7;
            } else {
                revert InvalidTokenId(msg.sender, ids[i]);
            }
            if (values[i] == 0) {
                revert InvalidTokenValue(values[i], 0);
            }
            totalAsh += (values[i] * weight);
        }
        // boost the total ash based on the multipliers
        uint256 multiplierInfo = multiplierInfos[from];
        if (data.length > 0) {
            // decode proof & newAnichessGameMultiplierNumerator from data
            (bytes32[] memory proof, uint256 newAnichessGameMultiplierNumerator) = abi.decode(data, (bytes32[], uint256));
            (multiplierInfo) = _setAnichessGameMultiplierNumerator(proof, from, multiplierInfo, newAnichessGameMultiplierNumerator);
        }
        uint256 tokenMultiplier = uint128(multiplierInfo);
        uint128 anichessGameMultiplierNumerator = uint128(multiplierInfo >> 128);

        if (tokenMultiplier > 0) {
            totalAsh *= tokenMultiplier;
        }
        if (anichessGameMultiplierNumerator > 0) {
            totalAsh = (totalAsh * anichessGameMultiplierNumerator) / DENOMINATOR;
        }

        // update the user status
        userAshPerCycle[cycle][from] += totalAsh;
        // update the pool status
        totalAshPerCycle[cycle] += totalAsh;

        IERC1155Burnable(msg.sender).batchBurnFrom(address(this), ids, values);
        emit GenerateAsh(from, cycle, ids, values, totalAsh, multiplierInfo);

        return this.onERC1155BatchReceived.selector;
    }
}
