// SPDX-License-Identifier: MIT
pragma solidity 0.8.22;

import {ERC1155TokenReceiver} from "@animoca/ethereum-contracts/contracts/token/ERC1155/ERC1155TokenReceiver.sol";
import {IERC1155Burnable} from "@animoca/ethereum-contracts/contracts/token/ERC1155/interfaces/IERC1155Burnable.sol";
import {MerkleProof} from "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol";

/**
 * @title OrbsBurnPool Contract
 * @dev This contract allows users to burn tokens and calculate rewards based on the amount of tokens burned.
 */
contract OrbsBurnPool is ERC1155TokenReceiver {
    using MerkleProof for bytes32[];

    /// @notice The denominator for the multiplier.
    uint256 internal constant _DENOMINATOR = 10_000;

    /// @notice The token ID of RoC for setting the token multiplier.
    uint256 public constant MISSING_ORB_TOKEN_ID = 1;

    /// @notice The token weights for calculating Ash.
    uint256 public constant BURN_WEIGHT_TOKEN_1 = 1;
    uint256 public constant BURN_WEIGHT_TOKEN_2 = 3;
    uint256 public constant BURN_WEIGHT_TOKEN_3 = 3;
    uint256 public constant BURN_WEIGHT_TOKEN_4 = 5;
    uint256 public constant BURN_WEIGHT_TOKEN_5 = 9;
    uint256 public constant BURN_WEIGHT_TOKEN_6 = 25;
    uint256 public constant BURN_WEIGHT_TOKEN_7 = 16;

    /// @notice The Riddle Of Chaos multiplier.
    uint256 public constant ROC_MULTIPLIER = 2;

    /// @notice The IERC1155Burnable erc1155 contracts burn to generate ASH.
    IERC1155Burnable public immutable ORB_OF_POWER;

    /// @notice The IERC1155 erc1155 contract for setting the token multiplier.
    IERC1155Burnable public immutable MISSING_ORB;

    /// @notice The initial time of the contract.
    uint256 public immutable INITIAL_TIME;

    /// @notice The duration of each cycle.
    uint256 public immutable CYCLE_DURATION;

    /// @notice The maximum cycle.
    uint256 public immutable MAX_CYCLE;

    /// @notice The Merkle root for setting the puzzleMultiplier.
    bytes32 public immutable MERKLE_ROOT;

    /// @notice The total amount of ASH generated in each cycle.
    mapping(uint256 => uint256) public totalAshPerCycle;

    /// @notice The total amount of ASH generated by each user in each cycle.
    mapping(uint256 => mapping(address => uint256)) public userAshPerCycle;

    /// @notice The orb multipliers for each user, first 128 bits are the puzzleMultiplier numerator, last 128 bits are the roc multiplier.
    mapping(address => uint256) public orbMultipliers;

    /// @notice Event emitted when ASH are generated.
    event GenerateAsh(
        address indexed burner,
        uint256 indexed cycle,
        uint256[] ids,
        uint256[] values,
        uint256 ash,
        uint256 totalAsh,
        uint256 orbMultiplier
    );

    /// @notice Event emitted when the multiplier info is updated.
    event UpdateOrbMultiplier(address indexed recipient, uint256 curOrbMultiplier, uint256 updatedOrbMultiplier);

    /// @notice Error thrown when the token ID is invalid.
    error InvalidTokenId(address token, uint256 tokenId);

    /// @notice Error thrown when the token is not approved.
    error InvalidTokenAddress(address token);

    /// @notice Error thrown when the token amount is invalid.
    error InvalidTokenValue(address token, uint256 tokenId, uint256 value);

    /// @notice Error thrown when the cycle is invalid.
    error InvalidCycle(uint256 cycle);

    /// @notice Error thrown when the wallet already has the ROC multiplier been set.
    error AlreadySetROCMultiplier(address wallet);

    /// @notice Error thrown when the proof is invalid.
    error InvalidProof(address recipient, uint256 puzzleGameMultiplierNumerator);

    /// @notice Error thrown when the cycle duration is invalid.
    error ZeroCycleDuration();

    /// @notice Error thrown when the cycle is invalid.
    error ZeroMaxCycle();

    /**
     * @notice Constructor for the OrbsBurnPool contract.
     * @param initialTime The initial time of the contract.
     * @param cycleDuration The duration of each cycle.
     * @param maxCycle The maximum cycle.
     * @param orbOfPower The IERC1155Burnable erc1155 contract burn to generate ASH.
     * @param merkleRoot The Merkle root of the Puzzle Game multiplier claim.
     * @param missingOrb The IERC1155Burnable erc1155 missing orb contract for setting the token multiplier.
     * @dev Throws if the cycle duration is zero.
     * @dev Throws if the max cycle is zero.
     */
    constructor(
        uint256 initialTime,
        uint256 cycleDuration,
        uint256 maxCycle,
        bytes32 merkleRoot,
        IERC1155Burnable orbOfPower,
        IERC1155Burnable missingOrb
    ) {
        INITIAL_TIME = initialTime;

        if (cycleDuration == 0) {
            revert ZeroCycleDuration();
        }
        CYCLE_DURATION = cycleDuration;

        if (maxCycle == 0) {
            revert ZeroMaxCycle();
        }
        MAX_CYCLE = maxCycle;
        MERKLE_ROOT = merkleRoot;
        ORB_OF_POWER = orbOfPower;
        MISSING_ORB = missingOrb;
    }

    /**
     * @notice Get the current cycle.
     * @return cycle The current cycle.
     */
    function currentCycle() public view returns (uint256) {
        return (block.timestamp - INITIAL_TIME) / CYCLE_DURATION;
    }

    /**
     * @notice Set the Orb multiplier by burning the Missing Orb token 1
     * @notice and set the Puzzle Game multiplier through a Merkle proof in the data field.
     * @param from The wallet address.
     * @param id The token ID.
     * @param value The token value.
     * @param data The merkle proof data and multiplier value for setting the token multiplier.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the cycle is invalid.
     * @dev Throws if the token ID is invalid.
     * @dev Throws if the token amount is invalid.
     * @dev Throws if the token multiplier has already been set.
     */
    function onERC1155Received(address, address from, uint256 id, uint256 value, bytes calldata data) external override returns (bytes4) {
        if (msg.sender != address(MISSING_ORB)) {
            revert InvalidTokenAddress(msg.sender);
        }
        if (id != MISSING_ORB_TOKEN_ID) {
            revert InvalidTokenId(msg.sender, id);
        }

        if (value != 1) {
            revert InvalidTokenValue(msg.sender, id, value);
        }

        uint256 cycle = currentCycle();
        if (cycle > MAX_CYCLE) {
            revert InvalidCycle(cycle);
        }

        uint256 curOrbMultiplier = orbMultipliers[from];
        if (uint128(curOrbMultiplier) > 0) {
            revert AlreadySetROCMultiplier(from);
        }

        IERC1155Burnable(msg.sender).burnFrom(address(this), id, value);

        uint256 newOrbMultiplier = curOrbMultiplier | ROC_MULTIPLIER;
        if (data.length > 0) {
            if ((curOrbMultiplier >> 128) == 0) {
                (bytes32[] memory proof, uint256 puzzleGameMultiplierNumerator) = abi.decode(data, (bytes32[], uint256));
                bytes32 leaf = keccak256(abi.encodePacked(from, puzzleGameMultiplierNumerator));
                if (!proof.verify(MERKLE_ROOT, leaf)) {
                    revert InvalidProof(from, puzzleGameMultiplierNumerator);
                }

                newOrbMultiplier = (puzzleGameMultiplierNumerator << 128) | newOrbMultiplier;
            }
        }
        orbMultipliers[from] = newOrbMultiplier;
        emit UpdateOrbMultiplier(from, curOrbMultiplier, newOrbMultiplier);

        return this.onERC1155Received.selector;
    }

    /**
     * @notice Burn the tokens and calculate the ash.
     * @param from The wallet address.
     * @param ids The token IDs to burn.
     * @param values The amount of tokens to burn.
     * @param data The merkle proof data and multiplier value for setting the token multiplier.
     * @return The ERC1155Received selector.
     * @dev Throws if the token is invalid.
     * @dev Throws if the cycle is invalid.
     * @dev Throws if the token ID is invalid.
     * @dev Throws if the token amount is invalid.
     */
    function onERC1155BatchReceived(
        address,
        address from,
        uint256[] calldata ids,
        uint256[] calldata values,
        bytes calldata data
    ) external override returns (bytes4) {
        if (msg.sender != address(ORB_OF_POWER)) {
            revert InvalidTokenAddress(msg.sender);
        }

        uint256 cycle = currentCycle();
        if (cycle > MAX_CYCLE) {
            revert InvalidCycle(cycle);
        }

        IERC1155Burnable(msg.sender).batchBurnFrom(address(this), ids, values);

        uint256 ashGenerated = 0;
        for (uint256 i = 0; i < ids.length; i++) {
            if (values[i] == 0) {
                revert InvalidTokenValue(msg.sender, ids[i], values[i]);
            }

            if (ids[i] == 1) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_1);
            } else if (ids[i] == 2) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_2);
            } else if (ids[i] == 3) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_3);
            } else if (ids[i] == 4) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_4);
            } else if (ids[i] == 5) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_5);
            } else if (ids[i] == 6) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_6);
            } else if (ids[i] == 7) {
                ashGenerated += (values[i] * BURN_WEIGHT_TOKEN_7);
            } else {
                revert InvalidTokenId(address(ORB_OF_POWER), ids[i]);
            }
        }

        address userAddr = from;

        // boost the total ash based on the orbMultipliers
        uint256 curOrbMultiplier = orbMultipliers[userAddr];

        if (data.length > 0) {
            (bytes32[] memory proof, uint256 puzzleGameMultiplierNumerator) = abi.decode(data, (bytes32[], uint256));
            if ((curOrbMultiplier >> 128) == 0) {
                bytes32 leaf = keccak256(abi.encodePacked(userAddr, puzzleGameMultiplierNumerator));
                if (!proof.verify(MERKLE_ROOT, leaf)) {
                    revert InvalidProof(userAddr, puzzleGameMultiplierNumerator);
                }

                uint256 newOrbMultiplier = (puzzleGameMultiplierNumerator << 128) | curOrbMultiplier;
                orbMultipliers[userAddr] = newOrbMultiplier;
                emit UpdateOrbMultiplier(userAddr, curOrbMultiplier, newOrbMultiplier);
                curOrbMultiplier = newOrbMultiplier;
            }

            ashGenerated = (ashGenerated * puzzleGameMultiplierNumerator) / _DENOMINATOR;
        } else {
            uint256 puzzleGameMultiplierNumerator = curOrbMultiplier >> 128;
            if (puzzleGameMultiplierNumerator > 0) {
                ashGenerated = (ashGenerated * puzzleGameMultiplierNumerator) / _DENOMINATOR;
            }
        }

        uint256 rocMultiplier = uint128(curOrbMultiplier);
        if (rocMultiplier > 0) {
            ashGenerated *= rocMultiplier;
        }

        // update the user status
        uint256 userTotalAshPerCycle = userAshPerCycle[cycle][userAddr] + ashGenerated;
        userAshPerCycle[cycle][userAddr] = userTotalAshPerCycle;
        // update the pool status
        totalAshPerCycle[cycle] += ashGenerated;

        emit GenerateAsh(userAddr, cycle, ids, values, ashGenerated, userTotalAshPerCycle, curOrbMultiplier);

        return this.onERC1155BatchReceived.selector;
    }
}
